/*******************************************************************************
 * Copyright (c) 2013 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 ******************************************************************************/

package org.eclipse.e4.ui.internal.workbench;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtension;
import org.eclipse.core.runtime.IExtensionPoint;
import org.eclipse.core.runtime.IExtensionRegistry;
import org.eclipse.core.runtime.IRegistryEventListener;
import org.eclipse.e4.ui.workbench.modeling.EClassProvider;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EPackage;

/**
 * A concrete implementation of the {@link EClassProvider} which uses the Eclipse ExtensionRegistry to map java {@link Class}es to EMF {@link EClass}es.
 * 
 * <p>
 * This provider checks the Eclipse ExtensionRegistry for all registered EMF-packages, via the {@code "org.eclipse.emf.ecore.generated_package"}
 * ExtensionPoint generated by EMF, and builds a map out of it in which the package-name is the key and the EPackage Namespace URI is the value.
 * The {@link #getEClass(Class)} method uses this mapping to find the correct EPackage of the provided class and afterwards resolve the EClass from it.
 * </p>
 * 
 * <p>
 * <b>IMPORTANT:</b> The implementation is registered via OSGi Declarative Services, which uses a static one-to-one mapping for the Eclipse ExtensionRegistry.
 * Which causes a lazy loading and guarantees that the methods {@link #bindExtensionRegistry(IExtensionRegistry)}, {@link #activate()}, and {@link #deactivate()}
 * are called in a thread-safe way.
 * </p>
 */
public class EClassProviderImpl implements EClassProvider {

	/** A reference to the used Eclipse ExtensionRegistry. */
	private IExtensionRegistry extensionRegistry;

	/** An ExtensionRegistryListener which will build the required package to EPackage-Namespace-URI mapping. */
	private volatile EmfGeneratedPackages emfGeneratedPackages;
	
	/**
	 * Method to specify the Eclipse ExtensionRegistry which should be used to build the mapping.
	 * 
	 * <p>
	 * This method will be called by OSGi Declarative Service if the it was able to find a reference.
	 * </p>
	 * 
	 * @param extensionRegistry the Eclipse ExtensionRegistry to use for building the mapping
	 */
	public void bindExtensionRegistry(IExtensionRegistry extensionRegistry) {
		this.extensionRegistry = extensionRegistry;
	}

	/**
	 * Activates this service by building the appropriate mapping and registering the required listeners.
	 * @throws IllegalStateException If no ExtensionRegistry was specified previously or activate was already called. 
	 */
	public void activate() {
		if (extensionRegistry == null) { // just for safety's sake
			throw new IllegalStateException("Can't activate before ExtensionRegistry is bound!"); //$NON-NLS-1$
		}
		
		if( emfGeneratedPackages != null ){ // just for safety's sake
			throw new IllegalStateException("Can't activate because it's already activated!"); //$NON-NLS-1$
		}
		
		emfGeneratedPackages = new EmfGeneratedPackages();
		extensionRegistry.addListener(emfGeneratedPackages, EmfGeneratedPackages.EP_GENERATED_PACKAGE);
		emfGeneratedPackages.initialize(extensionRegistry);
	}

	/**
	 * Deactivates this service by clean-up the mapping and unregistering of the listeners.
	 */
	public void deactivate() {
		EmfGeneratedPackages emfPackages = emfGeneratedPackages; // keep local reference
		emfGeneratedPackages = null; // clear global one
		
		if (emfPackages != null) {
			extensionRegistry.removeListener(emfGeneratedPackages);
			emfPackages.dispose();
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.eclipse.e4.ui.workbench.modeling.EClassProvider#getEClass(java.lang.Class)
	 */
	public EClass getEClass(Class<?> clazz) {
		EmfGeneratedPackages emfPackages = emfGeneratedPackages; // use a local reference to minimize the thread-synchronization at this important step
		
		if (emfPackages != null) {
			String ePackageNameSpace = emfPackages.getEPackageNameSpaceURI(clazz);

			if (ePackageNameSpace != null) {
				EPackage ePackage = EPackage.Registry.INSTANCE.getEPackage(ePackageNameSpace);

				if (ePackage != null) {
					/*
					 * resolve the EClass from the generated package done with an
					 * implementation created by EMF (uses a Map internally)
					 */
					EClassifier eClass = ePackage.getEClassifier(clazz.getSimpleName());

					/*
					 * EPackage#getECassifier() doesn't always work, because if somebody switched
					 * the "Interface Name Pattern" of the EMF-genmodel attribute, the name of the
					 * class and its interface name will differ and null will be returned.
					 */
					if (eClass == null) {
						/*
						 * But an EPackage instance for the class was already received so the
						 * chances are good that this is a model element and so an alternative way
						 * to find the EClass is used.
						 * 
						 * Caching would be possible here but the list of EClassifier shouldn't be
						 * that long (~20 entries) and so this should be fine.
						 */
						for (EClassifier eClassifier : ePackage.getEClassifiers()) {
							if (clazz.equals(eClassifier.getInstanceClass())) {
								eClass = eClassifier;
								break; // exit loop, because the element was found
							}
						}
					}

					if (eClass instanceof EClass) {
						return (EClass) eClass;
					}
				}
			}
		}
		return null;
	}

	/**
	 * An Eclipse ExtensionRegistry-Listener which will build the required map to find the EPackage of a normal java package.
	 * <p>
	 * This Listener must be registered on EMF's {@value #EP_GENERATED_PACKAGE} extension point to build the appropriate mapping between
	 * java-package and EMF EPackage.
	 * </p>
	 */
	private static final class EmfGeneratedPackages implements IRegistryEventListener {

		/** The extension point name which holds the required information. */
		public static final String EP_GENERATED_PACKAGE = "org.eclipse.emf.ecore.generated_package"; //$NON-NLS-1$

		/** The configuration element inside the extension point which holds the required information. */
		private static final String CONFIG_ELEMENT_NAME = "package"; //$NON-NLS-1$
		/** Attribute name which holds the EMF EPackage Namespace URI. */
		private static final String CONFIG_ATTR_EPACKAGE_URI = "uri"; //$NON-NLS-1$
		/** Attribute name which holds the EMF EPackage class-name. */
		private static final String CONFIG_ATTR_EPACKAGE_IMPL = "class"; //$NON-NLS-1$

		/** Holds the mapping between java package-name and EMF EPackage Namespace URI. */
		private final ConcurrentMap<String, String> packageToEPackageNampeSpace = new ConcurrentHashMap<String, String>();
		
		/** Holds the required information per extension point which is needed to clean-up in the {@link #removed(IExtension[])} method. */
		private final ConcurrentMap<IExtension, List<String>> registeredPackages = new ConcurrentHashMap<IExtension, List<String>>();

		/**
		 * This will initialize the mapping for the given Eclipse ExtensionRegistry.
		 * 
		 * <p>
		 * The method will retrieve all {@link #EP_GENERATED_PACKAGE} extensions form the given Eclipse
		 * ExtensionRegistry and initializes the basic mapping.
		 * </p>
		 * 
		 * @param extensionRegistry the Eclipse ExtensionRegistry on which the listener is already registered
		 */
		public void initialize(IExtensionRegistry extensionRegistry) {
			if (extensionRegistry == null) {
				throw new IllegalArgumentException("No ExtensionRegistry given!"); //$NON-NLS-1$
			}
			
			IExtensionPoint epGeneratedPackage = extensionRegistry.getExtensionPoint(EP_GENERATED_PACKAGE);
			if( epGeneratedPackage != null ){
				added(epGeneratedPackage.getExtensions());
			}
		}

		/**
		 * Clean-up all mappings.
		 */
		public void dispose() {
			packageToEPackageNampeSpace.clear();
			registeredPackages.clear();
		}

		/**
		 * A lookup method which returns the EMF EPackage Namespace URI for the appropriate class.
		 * @param clazz the java class for which the EMF EPackage Namespace URI should be found
		 * @return the EMF EPackage Namespace URI for the appropriate class or null if none could be found (e.g.: not an EMF class, the given class is null, ...)
		 */
		public String getEPackageNameSpaceURI(Class<?> clazz) {
			if (clazz != null) {
				return packageToEPackageNampeSpace.get(clazz.getPackage().getName()); // the package-name of the class is the entry-point to the mapping
			}

			return null;
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.eclipse.core.runtime.IRegistryEventListener#added(org.eclipse.core.runtime.IExtension[])
		 */
		public void added(IExtension[] extensions) {
			for( IExtension extension : extensions ){
				List<String> elementsToCleanup = addToMapping(extension.getConfigurationElements());
				
				if( elementsToCleanup != null ){
					registeredPackages.put(extension, elementsToCleanup); // keep the list of registered packages per Extension to remove them in the #remove(IExtension[]) method 
				}
			}
		}

		/*
		 * (non-Javadoc)
		 * @see org.eclipse.core.runtime.IRegistryEventListener#removed(org.eclipse.core.runtime.IExtension[])
		 */
		public void removed(IExtension[] extensions) {
			for( IExtension extension : extensions ){
				List<String> modelPackageNamesToRemove = registeredPackages.get(extension);
				
				if( modelPackageNamesToRemove != null ){
					// clean-up
					for( String modelPackageName : modelPackageNamesToRemove ){
						packageToEPackageNampeSpace.remove(modelPackageName);
					}
					
					registeredPackages.remove(extension);
				}				 
			}
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.eclipse.core.runtime.IRegistryEventListener#added(org.eclipse.core.runtime.IExtensionPoint[])
		 */
		public void added(IExtensionPoint[] extensionPoints){
			// not of interest
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.eclipse.core.runtime.IRegistryEventListener#removed(org.eclipse.core.runtime.IExtensionPoint[])
		 */
		public void removed(IExtensionPoint[] extensionPoints){
			// not of interest
		}

		/**
		 * Reads the information from the given {@link IConfigurationElement}s and updates the mapping.
		 * @param configurationElements the elements to read the information from
		 * @return the list of packages which were put to the {@link #packageToEPackageNampeSpace} mapping or <code>null</code> if none were put into that list
		 */
		private List<String> addToMapping(IConfigurationElement[] configurationElements) {
			if (configurationElements == null) {
				return null;
			}
			
			List<String> allMappedEntried = new ArrayList<String>();

			for (IConfigurationElement configElement : configurationElements) {
				if (configElement.getName().equals(CONFIG_ELEMENT_NAME)) {
					String modelPackageName = extractPackage(configElement.getAttribute(CONFIG_ATTR_EPACKAGE_IMPL));

					if (modelPackageName != null) {
						// update the mapping
						if( packageToEPackageNampeSpace.putIfAbsent(modelPackageName, configElement.getAttribute(CONFIG_ATTR_EPACKAGE_URI) ) == null ){
							// no other thread has done this before so update the return information
							allMappedEntried.add(modelPackageName);
						}
					}
				}
			}
			
			return allMappedEntried.isEmpty() ? null : allMappedEntried;
		}

		/**
		 * Helper method to extract the java package-name from the provided EPackage classname.
		 * @param ePackageImpl the EPackage classname specified in the Extension <code>org.eclipse.emf.ecore.generated_package/package/@class</code>
		 * @return the appropriate java package-name or null if it couldn't be extracted
		 */
		private static String extractPackage(String ePackageImpl) {
			if (ePackageImpl != null) {
				int lastDot = ePackageImpl.lastIndexOf('.');

				if (lastDot >= 0) {
					String packageName = ePackageImpl.substring(0, lastDot); // this should be enough for normal EMF models

					/*
					 * But if the EMF genmodel was modified and the EMF Metadata will not be generated (as in all UI related elements)
					 * the EPackage-Implementation will be referenced instead of the EPackage-Interface. To check this we relay on the
					 * EMF naming convention which causes the concrete implemenation to be inside of an "impl" package.
					 * 
					 * CAUTION: If somebody also changes the EMF genmodel attribute "Package Suffixes/Implementation" this method will not
					 * be able to extract the package-name and the entire mechanism will not work anymore.
					 */
					if (packageName.endsWith(".impl")) { // default implementation name generated by EMF if "Suppress EMF Metadata" is activated //$NON-NLS-1$
						return packageName.substring(0, packageName.length() - 5); // 5 == ".impl".length()
					}

					return packageName;
				}
			}

			return null;
		}
	}
}
